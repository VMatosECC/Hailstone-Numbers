// Hailstone-Numbers.cpp 
// Author:  V. Matos
/* *****************************************************************************************************************
   Print and plot a Hailstone-Number sequence
   A Hailstone sequence of numbers is generated by the Collatz conjecture. For example, for a starting number of 7, 
   the sequence is 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1, .... 
   The general rule for the Hailstone sequence is 
                         h(x) = { x/2 if x is even, or 3x + 1 if x is odd }
   Such sequences are called hailstone sequences because the values typically rise and fall, somewhat analogously 
   to a hailstone inside a cloud.
   While a hailstone eventually becomes so heavy that it falls to ground, every starting positive integer EVER TESTED  
   has produced a hailstone sequence that eventually drops down to the number 1 and then "bounces" into 
   the small loop 4, 2, 1, ....

   Resources: Hailstorm Numbers (3X + 1) https://www.youtube.com/watch?v=094y1Z2wpJg&ab_channel=Veritasium

*/
#include <iostream>
#include <iomanip>
#include <vector>
using namespace std;
const int MAXROW = 70;

long sumDigits(long x);
void plot(vector<long> v);


int main()
{
    vector<long> vsd;
    cout << "Enter an integer number: ";
    long x;
    cin >> x;
    vsd.push_back(x);
    while (x != 1)
    {

        if (x % 2 == 0)
            x = x / 2;
        else
            x = 3 * x + 1;
        cout << x << "(" << sumDigits(x) << ")  ";
        vsd.push_back(x);
    }
    plot(vsd);
}
//User-defined methods ---------------------------------------------
long sumDigits(long x)
{
    long sum = 0;
    while (x > 0)
    {
        sum += (x % 10);
        x /= 10;
    }
    return sum;
}

void plot(vector<long> v)
{
    long largest = v[0];
    for (int i = 1; i < v.size(); i++)
        if (v[i] > largest) largest = v[i];

    cout << endl;
    double scaleFactor = (double)MAXROW / largest;
    for (int i = 0; i < v.size(); i++)
    {
        int adjusted = v[i] * scaleFactor;
        cout << setw(10) << left << v[i];
        for (int j = 0; j < adjusted; j++) cout << "*";
        cout << endl;
    }
    cout << endl;
}

